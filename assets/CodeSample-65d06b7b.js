/* empty css                                                                   */import{_ as h,X as l,Z as d,$ as r,Y as p,n as t,a3 as e,a4 as n,ac as m,ad as u}from"./index-b4639e08.js";import{V as f}from"./VContainer-2e9cc470.js";import{V as i}from"./VDivider-7acf2fa2.js";import{V as s}from"./VImg-9c8f8ad3.js";import"./color-564ff180.js";const _="/assets/Tick-fedbe044.png",g="/assets/ComputeDosageMap-9c5cf73b.png",b="/assets/tools-8f7a5b33.png",y="/assets/generate-66cef64d.png",v="/assets/extend-7919952c.png",k="/assets/accumulate-2c19f991.png",x="/assets/shade-ff020c87.png",T={},o=a=>(m("data-v-e32a3e00"),a=a(),u(),a),w=o(()=>e("h1",{class:"text-h2 d-flex text-center justify-center"},"Code sample",-1)),V={class:""},C=o(()=>e("br",null,null,-1)),I=o(()=>e("a",{target:"_blank",href:"https://github.com/orjfickel/Small-Project-UV-Robot-Ray-Tracer/blob/main/Final_Report_Small_Project_UV_Ray_Tracer.pdf"}," project's report",-1)),j=o(()=>e("br",null,null,-1)),B=o(()=>e("span",null," ComputeDosageMap() runs a few kernels to trace and count the rays for each light position. Shade() then uses the resulting photon counts to determine UV dosage and the corresponding triangle colors. ",-1)),S=o(()=>e("span",null," Below are the relevant data structures used by the computation kernels. ",-1)),U=o(()=>e("span",null," The first kernel in the ComputeDosageMap() loop simply generates an array of photon rays for a given light position. To this end, first a random position on the line is picked. Then the direction is calculated by first setting the vertical y component to a random value between -1 and 1, then generating a random point on the unit circle in the x-z plane, and finally scaling these x and z components to match the y component. By doing this we ensure that the direction has a cosine distribution vertically along the light source, and is uniformly distributed horizontally around the light source. ",-1)),D=o(()=>e("span",null," The second kernel extends these rays and intersects them with the scene geometry using its BVH. I've excluded the code for building and intersecting the BVH, as this was directly adapted from elsewhere. This kernel also immediately performs an atomic increment of the number of photons that the hit triangle has received. ",-1)),L=o(()=>e("span",null," The last kernel in the loop then accumulates these numbers into an array for all the light positions together. For the cumulative dosage heatmap these values are multiplied by the duration corresponding to the light position, and then summed together. For the max irradiation heatmap on the other hand the number of photons is only replaced if the new value is larger. ",-1)),O=o(()=>e("span",null," After finishing this loop, the final two kernels compute the actual irradiance and UV dose. These values are then normalised and scaled over the heatmap gradient. The color values are inserted into an OpenGL vertex buffer which has been made directly available to the OpenCL kernel. This buffer is used by the OpenGL vertex shader to directly shade the vertex with the color stored in the buffer. ",-1));function R(a,z){const c=l("router-link");return p(),d(f,{class:"pt-9"},{default:r(()=>[w,t(i,{class:"mt-8 mb-10"}),e("span",V,[n(" Here I'll present an example of some of the C++ and OpenCL code I have written, specifically the central code for the "),t(c,{to:"/projects/smallproject"},{default:r(()=>[n("UV ray tracer project")]),_:1}),n(" (click for more details, including the full source code)."),C,n(" The function of this code is to use the input of a 3D model of a room and a number of UV lamps, and show how much UV light is received by the room's surfaces. This is done by shooting rays from these lamps and counting how often the room mesh's triangles are hit. The rationalisation behind this method can be found in the "),I,n(". "),j,n(" To keep it brief, I'll only outline the main loop over the OpenCL computation kernels. The Tick() function directly calls the computation functions if the dosage map hasn't already been computed. ")]),t(s,{src:_}),B,t(s,{src:g}),S,t(s,{"max-width":"400",src:b}),U,t(s,{src:y}),D,t(s,{src:v}),L,t(s,{src:k}),O,t(s,{src:x}),t(i,{class:"mt-8"})]),_:1})}const A=h(T,[["render",R],["__scopeId","data-v-e32a3e00"]]);export{A as default};
